<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Striker: 10-Weapon Arsenal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #dbe6f6, #c5796d);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            touch-action: none;
        }

        @keyframes skyChange {
            0% { background: linear-gradient(to bottom, #E0F7FA, #81D4FA); }
            50% { background: linear-gradient(to bottom, #fce38a, #f38181); }
            100% { background: linear-gradient(to bottom, #E0F7FA, #81D4FA); }
        }
        body { animation: skyChange 60s infinite alternate; }

        #gameContainer {
            position: relative;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            border-radius: 16px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.05s;
        }

        canvas { display: block; }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            z-index: 5;
        }

        .score-board {
            color: #fff; font-size: 24px; font-weight: 800;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            position: absolute; top: 15px; left: 20px;
        }

        .combo-display {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            font-size: 32px; font-weight: 900; color: #ffeaa7;
            text-shadow: 0 0 10px #e17055; opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }
        .combo-display.active { opacity: 1; transform: translateX(-50%) scale(1.1); }

        .hp-display {
            position: absolute; top: 50px; left: 20px;
            font-size: 20px; text-shadow: 0 2px 4px rgba(0,0,0,0.2); white-space: nowrap;
        }
        .hp-heart { color: #ff7675; margin-right: 2px; display: inline-block; transition: opacity 0.2s; }
        .hp-heart.lost { opacity: 0.2; filter: grayscale(1); }

        /* Ê≠¶Âô®ÊßΩ‰ΩçÊòæÁ§∫ */
        .weapon-slots {
            position: absolute; top: 50px; right: 20px;
            display: flex; gap: 5px; flex-wrap: wrap; justify-content: flex-end; width: 200px;
        }
        .weapon-dot {
            width: 12px; height: 12px; border-radius: 50%;
            border: 2px solid #fff; box-shadow: 0 0 5px rgba(0,0,0,0.3);
            background: rgba(255,255,255,0.2);
        }

        .boss-hp-container {
            position: absolute; top: 20px; right: 20px;
            width: 150px; height: 20px;
            background: rgba(0,0,0,0.3); border-radius: 10px;
            display: none; overflow: hidden; border: 2px solid #fff;
        }
        #bossHpBar {
            width: 100%; height: 100%;
            background: linear-gradient(90deg, #FF5252, #FF1744);
            transition: width 0.1s;
        }

        .float-text {
            position: absolute; font-weight: bold; font-size: 20px;
            text-shadow: 0 0 5px rgba(0,0,0,0.5); pointer-events: none;
            animation: floatUp 0.8s forwards; z-index: 20;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-30px) scale(1.3); opacity: 1; }
            100% { transform: translateY(-60px) scale(1); opacity: 0; }
        }

        .damage-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: red; opacity: 0; pointer-events: none;
            transition: opacity 0.1s; z-index: 4;
        }

        #startScreen, #gameOverScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.85); backdrop-filter: blur(10px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 10; pointer-events: auto; text-align: center;
        }

        h1 { color: #6C63FF; font-size: 42px; margin: 0 0 10px 0; text-shadow: 3px 3px 0px #fff; letter-spacing: 2px; }
        p { color: #555; font-size: 16px; margin-bottom: 20px; line-height: 1.6; max-width: 80%; }
        .highlight { color: #FF6B6B; font-weight: bold; }

        button {
            background: linear-gradient(45deg, #FF6B6B, #FF8E53);
            color: white; border: none; padding: 16px 45px;
            font-size: 22px; font-weight: bold; border-radius: 50px;
            cursor: pointer; box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
            transition: transform 0.2s, box-shadow 0.2s; margin-bottom: 15px;
        }
        button:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 12px 25px rgba(255, 107, 107, 0.5); }
        button:active { transform: translateY(1px); }

        .hidden { display: none !important; }

        .donation-box {
            margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.6);
            border-radius: 16px; border: 1px solid #ddd;
            display: flex; flex-direction: column; align-items: center; min-width: 150px;
        }
        .donation-title { font-size: 14px; color: #888; margin-bottom: 8px; font-weight: bold; }
        .donation-img { max-width: 150px; max-height: 150px; border-radius: 8px; display: block; }
        .qr-placeholder {
            width: 120px; height: 120px; border: 2px dashed #bbb; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            color: #999; font-size: 12px; background: rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="480" height="700"></canvas>
    <div id="damageOverlay" class="damage-overlay"></div>

    <div id="uiLayer" class="ui-layer">
        <div class="score-board">SCORE: <span id="scoreDisplay">0</span></div>
        <div id="comboDisplay" class="combo-display">COMBO x2</div>
        <div class="hp-display" id="hpDisplay"></div>
        <div id="weaponSlots" class="weapon-slots"></div>
        <div id="bossHpContainer" class="boss-hp-container">
            <div id="bossHpBar"></div>
        </div>
    </div>

    <div id="startScreen">
        <h1>‚ú® ÈúìËôπÁ™ÅÂáªÔºöÂçÅËØ´ ‚ú®</h1>
        <p>
            <span class="highlight">Êó†ÈôêËøõÂåñÔºö</span>ÊØè1wÂàÜ ÊïåË°Ä+20% ÊîªÈÄü+10%<br>
            <span class="highlight">ÁÅ´ÂäõÊàêÈïøÔºö</span>ÊØè1wÂàÜ Â≠êÂºπ‰º§ÂÆ≥+8%<br>
            <span class="highlight">Êñ∞Ê≠¶Â∫ìÔºö</span>10 Áßç‰∏çÂêåÂ≠êÂºπ Ëá™Áî±Ê∑∑Êê≠
        </p>
        <button id="startBtn">ÂÖ®ÈÄüÂçáÁ©∫</button>
        
        <div class="donation-box">
            <div class="donation-title">‚òï ÊîØÊåÅÂºÄÂèëËÄÖ</div>
            <img class="donation-img" src="" alt="ËµûËµèÁ†Å" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="qr-placeholder" style="display:none;">[Âú®Ê≠§Â§ÑÊèíÂÖ•‰∫åÁª¥Á†Å]</div>
        </div>
    </div>

    <div id="gameOverScreen" class="hidden">
        <h1 style="color: #FF5252">‰ªªÂä°Â§±Ë¥•</h1>
        <p>ÊúÄÁªàÂæóÂàÜ: <span id="finalScore" style="font-size: 32px; font-weight: bold; color: #333">0</span></p>
        <button id="restartBtn">ÈáçÊñ∞ÊåëÊàò</button>
    </div>
</div>

<script>
window.onload = function() {

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreDisplay');
    const comboEl = document.getElementById('comboDisplay');
    const hpEl = document.getElementById('hpDisplay');
    const weaponSlotsEl = document.getElementById('weaponSlots');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const gameContainer = document.getElementById('gameContainer');
    const bossHpContainer = document.getElementById('bossHpContainer');
    const bossHpBar = document.getElementById('bossHpBar');
    const uiLayer = document.getElementById('uiLayer');
    const damageOverlay = document.getElementById('damageOverlay');

    document.getElementById('startBtn').onclick = startGame;
    document.getElementById('restartBtn').onclick = startGame;

    const CONFIG = {
        maxActiveWeapons: 4, 
        maxWingmen: 3,     
        playerMaxHp: 5,    
        dropChance: 0.55, // Áï•ÂæÆÂ¢ûÂä†ÊéâÁéá‰ª•ÊîØÊåÅ10ÁßçÊ≠¶Âô®
        comboDecay: 150,
        bossSpawnScore: 800
    };

    const COLORS = {
        player: '#6C63FF',
        wingman: '#00cec9',
        
        // 10ÁßçÊ≠¶Âô®È¢úËâ≤
        bulletNormal: '#FFD700', // 1. ÈªÑ
        bulletLaser: '#00D2D3',  // 2. Èùí
        bulletHeavy: '#2d3436',  // 3. Èªë
        bulletHoming: '#a29bfe', // 4. Á¥´
        bulletPlasma: '#74b9ff', // 5. Ëìù
        bulletRapid: '#ff6b6b',  // 6. Á∫¢ (ÊÄ•ÈÄü)
        bulletSnipe: '#1dd1a1',  // 7. Áªø (ÁãôÂáª)
        bulletShuriken: '#e17055',// 8. Ê©ò (ÊâãÈáåÂâë)
        bulletBubble: '#81ecec', // 9. ÊµÖËìù (Ê∞îÊ≥°)
        bulletPulse: '#fd79a8',  // 10. Á≤â (ËÑâÂÜ≤)

        enemyBullet: '#FF5252',
        shield: '#74b9ff',
        
        enemySmall: '#FF9F43',
        enemyMedium: '#d63031',
        boss: '#6c5ce7',
        trapBomb: '#2d3436',
        dropHealth: '#00b894',
        dropWeapon: '#ff7675'
    };

    let gameState = {
        running: false,
        score: 0,
        frames: 0,
        shakeTimer: 0,
        bossActive: false,
        combo: 0,
        comboTimer: 0
    };

    let input = { x: canvas.width / 2, y: canvas.height - 100 };

    function updateInput(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        input.x = clientX - rect.left;
        input.y = clientY - rect.top;
    }
    canvas.addEventListener('mousemove', e => updateInput(e.clientX, e.clientY));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        updateInput(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    let entities = {
        player: null,
        bullets: [],
        enemies: [],
        enemyBullets: [],
        particles: [],
        drops: [],
        bombs: []
    };

    function addScore(amount, x, y) {
        gameState.comboTimer = CONFIG.comboDecay;
        gameState.combo++;
        comboEl.innerText = `COMBO x${gameState.combo}`;
        comboEl.classList.add('active');
        comboEl.style.animation = 'none';
        comboEl.offsetHeight; 
        comboEl.style.animation = null; 

        const multiplier = Math.min(gameState.combo, 50); 
        const finalScore = amount * multiplier;
        gameState.score += finalScore;
        scoreEl.innerText = gameState.score;
        createFloatingText(`+${finalScore} <span style="font-size:14px">x${multiplier}</span>`, x, y, '#ffeaa7');
    }

    function updateCombo() {
        if (gameState.combo > 0) {
            gameState.comboTimer--;
            if (gameState.comboTimer <= 0) {
                gameState.combo = 0;
                comboEl.classList.remove('active');
            }
        }
    }

    function screenShake(intensity) { gameState.shakeTimer = intensity; }
    function flashRed() {
        damageOverlay.style.opacity = 0.6;
        setTimeout(() => damageOverlay.style.opacity = 0, 150);
    }

    function createFloatingText(html, x, y, color) {
        const el = document.createElement('div');
        el.className = 'float-text';
        el.innerHTML = html;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = color;
        uiLayer.appendChild(el);
        setTimeout(() => el.remove(), 800);
    }

    function createExplosion(x, y, color, count = 10, speed = 1) {
        for(let i=0; i<count; i++) {
            entities.particles.push(new Particle(x, y, color, speed));
        }
    }

    function updateHpUI() {
        hpEl.innerHTML = '';
        for (let i = 0; i < CONFIG.playerMaxHp; i++) {
            const heart = document.createElement('span');
            heart.className = 'hp-heart';
            heart.innerText = '‚ù§Ô∏è';
            if (i >= entities.player.hp) heart.classList.add('lost');
            hpEl.appendChild(heart);
        }
    }

    function updateWeaponUI(activeWeapons) {
        weaponSlotsEl.innerHTML = '';
        activeWeapons.forEach(type => {
            let div = document.createElement('div');
            div.className = 'weapon-dot';
            let colorKey = 'bullet' + type.charAt(0).toUpperCase() + type.slice(1);
            div.style.backgroundColor = COLORS[colorKey] || '#fff';
            div.title = type;
            weaponSlotsEl.appendChild(div);
        });
    }

    class Player {
        constructor() {
            this.width = 44; this.height = 40;
            this.x = canvas.width / 2 - this.width / 2;
            this.y = canvas.height - 100;
            this.hp = CONFIG.playerMaxHp;
            this.invulTimer = 0;
            this.shield = false;
            this.shieldAlpha = 0;
            this.wingmen = 0;
            this.activeWeapons = ['normal']; 
            updateWeaponUI(this.activeWeapons);
        }

        update() {
            let targetX = Math.max(0, Math.min(canvas.width - this.width, input.x - this.width / 2));
            let targetY = Math.max(0, Math.min(canvas.height - this.height, input.y - this.height / 2));
            this.x += (targetX - this.x) * 0.15;
            this.y += (targetY - this.y) * 0.15;
            
            if (this.shield) this.shieldAlpha = 0.5 + Math.sin(gameState.frames * 0.1) * 0.2;
            if (this.invulTimer > 0) this.invulTimer--;
        }

        draw() {
            if (this.invulTimer > 0 && Math.floor(gameState.frames / 4) % 2 === 0) return;
            ctx.save();
            
            if (this.wingmen > 0) {
                ctx.fillStyle = COLORS.wingman;
                this.drawWingman(this.x - 25 + Math.sin(gameState.frames * 0.1) * 5, this.y + 15);
                if (this.wingmen > 1) this.drawWingman(this.x + this.width + 15 + Math.sin(gameState.frames * 0.1 + Math.PI) * 5, this.y + 15);
                if (this.wingmen > 2) this.drawWingman(this.x + this.width/2 - 10, this.y + 40 + Math.cos(gameState.frames * 0.1) * 3);
            }

            if (this.shield) {
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, 45, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(116, 185, 255, ${this.shieldAlpha})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            ctx.fillStyle = COLORS.player;
            ctx.shadowColor = COLORS.player;
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(this.x + this.width / 2, this.y); 
            ctx.lineTo(this.x + this.width, this.y + this.height); 
            ctx.lineTo(this.x + this.width / 2, this.y + this.height - 15); 
            ctx.lineTo(this.x, this.y + this.height); 
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(this.x + this.width/2, this.y + 25, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
        drawWingman(x, y) {
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 10, y + 20); ctx.lineTo(x - 10, y + 20); ctx.fill();
        }
        heal() {
            if (this.hp < CONFIG.playerMaxHp) {
                this.hp++; updateHpUI();
                createFloatingText("+HP", this.x, this.y, '#00b894');
                createExplosion(this.x + this.width/2, this.y + this.height/2, '#00b894', 15);
            } else {
                addScore(50, this.x, this.y);
            }
        }
        takeDamage() {
            if (this.invulTimer > 0) return;
            gameState.combo = 0;
            comboEl.classList.remove('active');
            if (this.shield) {
                this.shield = false;
                screenShake(10);
                createFloatingText("SHIELD BREAK", this.x, this.y, '#74b9ff');
                this.invulTimer = 60;
                return;
            }
            this.hp--; updateHpUI(); flashRed(); screenShake(20);
            this.invulTimer = 90;
            createExplosion(this.x + this.width/2, this.y + this.height/2, '#ff0000', 20);
            if (this.hp <= 0) gameOver();
        }
        
        addWeapon(type) {
            let weaponKey = type === 'spread' ? 'normal' : type;
            this.activeWeapons.push(weaponKey);
            if (this.activeWeapons.length > CONFIG.maxActiveWeapons) {
                this.activeWeapons.shift();
            }
            updateWeaponUI(this.activeWeapons);
        }
    }

    class TrapBomb {
        constructor() {
            this.radius = 25;
            this.x = Math.random() * (canvas.width - 50) + 25;
            this.y = -50;
            this.speed = Math.random() * 1.5 + 1;
            this.rotation = 0;
            this.remove = false;
            this.hp = 1;
        }
        update() {
            this.y += this.speed;
            this.rotation += 0.02;
            if (this.y > canvas.height + 50) this.remove = true;
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = COLORS.trapBomb;
            ctx.shadowColor = '#000'; ctx.shadowBlur = 10;
            ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 3;
            for(let i=0; i<8; i++) {
                ctx.rotate(Math.PI/4); ctx.beginPath(); ctx.moveTo(0, -this.radius); ctx.lineTo(0, -this.radius - 5); ctx.stroke();
            }
            ctx.rotate(-this.rotation);
            ctx.fillStyle = '#ff0000'; ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('‚ö†Ô∏è', 0, 2);
            ctx.restore();
        }
    }

    class Bullet {
        constructor(x, y, type, angle = 0, speed = 12) {
            this.x = x; this.y = y; this.type = type; this.angle = angle; this.speed = speed; this.remove = false;
            this.moveLogic = 'straight'; 
            
            // Áé©ÂÆ∂‰º§ÂÆ≥ÊàêÈïøÔºöÊØè10000ÂàÜÂ¢ûÂä†8%
            let dmgMultiplier = 1 + (Math.floor(gameState.score / 10000) * 0.08);

            // 10 ÁßçÊ≠¶Âô®ÂèÇÊï∞ÂÆö‰πâ
            if (type === 'laser') {
                this.width = 5; this.height = 40; this.speed = 22; this.damage = 4.0 * dmgMultiplier; this.color = COLORS.bulletLaser;
            } else if (type === 'heavy') {
                this.width = 16; this.height = 16; this.speed = 6; this.damage = 25 * dmgMultiplier; this.color = COLORS.bulletHeavy;
            } else if (type === 'homing') {
                this.width = 8; this.height = 12; this.speed = 8; this.damage = 2 * dmgMultiplier; this.color = COLORS.bulletHoming; this.moveLogic = 'homing';
            } else if (type === 'plasma') {
                this.width = 12; this.height = 8; this.speed = 10; this.damage = 3 * dmgMultiplier; this.color = COLORS.bulletPlasma; this.moveLogic = 'sine'; this.startX = x;
            } else if (type === 'rapid') { // Êñ∞ÔºöÊÄ•ÈÄü
                this.width = 4; this.height = 12; this.speed = 18; this.damage = 0.8 * dmgMultiplier; this.color = COLORS.bulletRapid;
            } else if (type === 'snipe') { // Êñ∞ÔºöÁãôÂáª
                this.width = 6; this.height = 25; this.speed = 25; this.damage = 8 * dmgMultiplier; this.color = COLORS.bulletSnipe;
            } else if (type === 'shuriken') { // Êñ∞ÔºöÊâãÈáåÂâë
                this.width = 10; this.height = 10; this.speed = 9; this.damage = 2.5 * dmgMultiplier; this.color = COLORS.bulletShuriken; this.moveLogic = 'spin';
            } else if (type === 'bubble') { // Êñ∞ÔºöÊ∞îÊ≥° (Â§ßÂà§ÂÆö)
                this.width = 18; this.height = 18; this.speed = 5; this.damage = 5 * dmgMultiplier; this.color = COLORS.bulletBubble;
            } else if (type === 'pulse') { // Êñ∞ÔºöËÑâÂÜ≤
                this.width = 8; this.height = 20; this.speed = 14; this.damage = 3.5 * dmgMultiplier; this.color = COLORS.bulletPulse;
            } else { // Normal
                this.width = 6; this.height = 14; this.speed = 12; this.damage = 1 * dmgMultiplier; this.color = COLORS.bulletNormal;
            }
        }
        update() {
            if (this.moveLogic === 'homing') {
                let target = null;
                let minDist = Infinity;
                entities.enemies.forEach(e => {
                    let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                    if (d < minDist && !e.remove) { minDist = d; target = e; }
                });
                if (target) {
                    let angleToTarget = Math.atan2((target.y+target.height/2) - this.y, (target.x+target.width/2) - this.x);
                    let vx = Math.cos(angleToTarget) * this.speed;
                    let vy = Math.sin(angleToTarget) * this.speed;
                    this.x += (vx * 0.2 + Math.sin(this.angle) * this.speed * 0.8);
                    this.y += (vy * 0.2 + -Math.cos(this.angle) * this.speed * 0.8);
                } else { this.y -= this.speed; }
            } else if (this.moveLogic === 'sine') {
                this.y -= this.speed;
                this.x = this.startX + Math.sin(this.y * 0.05 + gameState.frames * 0.1) * 30; 
            } else if (this.moveLogic === 'spin') {
                this.y -= this.speed; // ÊâãÈáåÂâëÊóãËΩ¨ÁâπÊïàÂú® draw ÈáåÂÅöÔºåÈÄªËæë‰∏äÁõ¥È£û
            } else {
                this.y -= this.speed;
                this.x += Math.sin(this.angle) * 3;
            }
            if (this.y < -50 || this.x < -50 || this.x > canvas.width + 50) this.remove = true;
        }
        draw() {
            ctx.save(); ctx.fillStyle = this.color; ctx.shadowColor = this.color;
            if (this.type === 'laser') {
                ctx.shadowBlur = 15; ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.fillStyle = '#fff'; ctx.fillRect(this.x + 1, this.y, this.width - 2, this.height);
            } else if (this.type === 'heavy') {
                ctx.shadowBlur = 8; ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(gameState.frames * 0.2); ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
            } else if (this.type === 'plasma') {
                ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
            } else if (this.type === 'homing') {
                ctx.shadowBlur = 5; ctx.translate(this.x, this.y); ctx.rotate(gameState.frames * 0.3);
                ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(4, 4); ctx.lineTo(-4, 4); ctx.fill();
            } else if (this.type === 'shuriken') {
                ctx.shadowBlur = 5; ctx.translate(this.x + this.width/2, this.y + this.height/2); 
                ctx.rotate(gameState.frames * 0.5); 
                ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(3, 0); ctx.lineTo(0, 8); ctx.lineTo(-3, 0); ctx.fill();
                ctx.rotate(Math.PI/2);
                ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(3, 0); ctx.lineTo(0, 8); ctx.lineTo(-3, 0); ctx.fill();
            } else if (this.type === 'bubble') {
                ctx.shadowBlur = 5; ctx.globalAlpha = 0.7;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.width/2, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle='#fff'; ctx.lineWidth=1; ctx.stroke();
            } else {
                ctx.shadowBlur = 5; ctx.beginPath(); ctx.roundRect(this.x, this.y, this.width, this.height, 3); ctx.fill();
            }
            ctx.restore();
        }
    }

    class Drop {
        constructor(x, y) {
            this.x = x; this.y = y; this.width = 32; this.height = 32; this.speed = 2; this.remove = false; this.yOffset = 0;
            const rand = Math.random();
            // ÊéâËêΩÊùÉÈáçË∞ÉÊï¥
            if (rand < 0.10) this.type = 'health';
            else if (rand < 0.20) this.type = 'shield';
            else if (rand < 0.30) this.type = 'wingman';
            
            else if (rand < 0.38) this.type = 'heavy';
            else if (rand < 0.46) this.type = 'laser';
            else if (rand < 0.54) this.type = 'homing';
            else if (rand < 0.62) this.type = 'plasma';
            else if (rand < 0.70) this.type = 'rapid';
            else if (rand < 0.78) this.type = 'snipe';
            else if (rand < 0.86) this.type = 'shuriken';
            else if (rand < 0.94) this.type = 'bubble';
            else this.type = 'pulse';
        }
        update() {
            this.y += this.speed; this.yOffset = Math.sin(gameState.frames * 0.1) * 5;
            let dx = entities.player.x - this.x; let dy = entities.player.y - this.y;
            // ÂáèÂ∞èÂê∏ÈôÑËåÉÂõ¥
            if (Math.sqrt(dx*dx + dy*dy) < 80) { this.x += dx * 0.08; this.y += dy * 0.08; }
            if (this.y > canvas.height) this.remove = true;
        }
        draw() {
            ctx.save(); ctx.translate(this.x + 16, this.y + 16 + this.yOffset);
            let color = '#fff', icon = '?';
            
            if(this.type === 'health') { color = COLORS.dropHealth; icon = 'üíö'; }
            else if(this.type === 'shield') { color = COLORS.shield; icon = 'üõ°Ô∏è'; }
            else if(this.type === 'wingman') { color = COLORS.wingman; icon = 'üõ∏'; }
            else {
                color = COLORS.dropWeapon; icon = 'üî¥';
                // ÁÆÄÂçïÁöÑÊ≠¶Âô®È¶ñÂ≠óÊØçÂõæÊ†á
                if(this.type === 'laser') icon = '‚ö°';
                if(this.type === 'heavy') icon = 'üí£';
                if(this.type === 'homing') icon = 'üéØ';
                if(this.type === 'plasma') icon = 'üåä';
                if(this.type === 'rapid') icon = 'üöÄ';
                if(this.type === 'snipe') icon = 'üèπ';
                if(this.type === 'shuriken') icon = '‚ú®';
                if(this.type === 'bubble') icon = '‚ö™';
                if(this.type === 'pulse') icon = '„Ä∞Ô∏è';
            }

            ctx.fillStyle = color; ctx.shadowColor = color; ctx.shadowBlur = 15;
            ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.font = '20px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(icon, 0, 2);
            ctx.restore();
        }
    }

    class Enemy {
        constructor(rank) { 
            this.rank = rank; this.remove = false;
            
            // Êïå‰∫∫ÊàêÈïøÔºöÊØè 10000 ÂàÜË°ÄÈáè+20%ÔºåÊîªÈÄü+10%
            let difficultyLevel = Math.floor(gameState.score / 10000);
            let hpMultiplier = 1 + (difficultyLevel * 0.20); 
            // ÊîªÈÄüÊèêÂçá (Èô§Êï∞ÂèòÂ∞è)Ôºå‰∏äÈôê‰∏∫ÂàùÂßãÁöÑ3ÂÄç (3.33)
            let speedDivisor = 1 + Math.min(difficultyLevel * 0.10, 2.33); 

            if (rank === 2) { // BOSS (Clown)
                this.width = 120; this.height = 100;
                this.x = canvas.width/2 - this.width/2; this.y = -150;
                this.maxHp = 600 * hpMultiplier; this.hp = this.maxHp;
                this.speed = 1; this.color = COLORS.boss;
                this.state = 'entering'; this.moveDir = 1;
                gameState.bossActive = true;
                bossHpContainer.style.display = 'block';
            } else if (rank === 1) { // Medium (Round Plane)
                this.width = 50; this.height = 50;
                this.x = Math.random() * (canvas.width - this.width); this.y = -60;
                this.maxHp = 40 * hpMultiplier; this.hp = this.maxHp;
                this.speed = Math.random() * 0.5 + 0.5; this.color = COLORS.enemyMedium;
            } else { // Small (Round Plane)
                this.width = 35; this.height = 35;
                this.x = Math.random() * (canvas.width - this.width); this.y = -50;
                this.maxHp = 2 * hpMultiplier; this.hp = this.maxHp;
                this.speed = Math.random() * 2 + 2.5; this.color = COLORS.enemySmall;
            }
            this.canShoot = rank > 0;
            this.baseShootTimer = Math.random() * 60 + 60;
            this.shootTimer = this.baseShootTimer / speedDivisor; // Â∫îÁî®ÊîªÈÄüÊàêÈïø
            this.speedDivisor = speedDivisor; // Â≠òÂÇ®Áî®‰∫éÈáçÁΩÆ
        }
        update() {
            if (this.rank === 2) {
                if (this.state === 'entering') {
                    this.y += this.speed; if (this.y > 50) this.state = 'fighting';
                } else {
                    this.x += this.moveDir * 1.5;
                    if (this.x <= 0 || this.x + this.width >= canvas.width) this.moveDir *= -1;
                    bossHpBar.style.width = (this.hp / this.maxHp * 100) + '%';
                }
            } else { this.y += this.speed; if (this.y > canvas.height) this.remove = true; }
            
            if (this.canShoot) {
                this.shootTimer--;
                if (this.shootTimer <= 0) {
                    let bx = this.x + this.width/2; let by = this.y + this.height;
                    
                    if(this.rank === 2) { 
                        // Boss ÊäÄËÉΩ
                        let pattern = Math.floor(Math.random() * 3);
                        if (pattern === 0) { 
                            for(let i=-2; i<=2; i++) entities.enemyBullets.push(new EnemyBullet(bx, by, i*2, 5));
                        } else if (pattern === 1) { 
                             for(let i=0; i<8; i++) {
                                 let ang = (Math.PI*2 / 8) * i;
                                 entities.enemyBullets.push(new EnemyBullet(bx, by + 20, Math.cos(ang)*5, Math.sin(ang)*5));
                             }
                        } else { 
                            let dx = entities.player.x - bx;
                            let dy = entities.player.y - by;
                            let dist = Math.sqrt(dx*dx + dy*dy);
                            entities.enemyBullets.push(new EnemyBullet(bx, by, (dx/dist)*7, (dy/dist)*7));
                        }
                        this.shootTimer = 40 / this.speedDivisor; // Boss ‰πüË¶ÅÂêÉÊîªÈÄüÂä†Êàê
                    } else if (this.rank === 1) {
                        entities.enemyBullets.push(new EnemyBullet(bx, by, 0, 6));
                        entities.enemyBullets.push(new EnemyBullet(bx, by, -1.5, 5));
                        entities.enemyBullets.push(new EnemyBullet(bx, by, 1.5, 5));
                        this.shootTimer = 90 / this.speedDivisor;
                    } else {
                        entities.enemyBullets.push(new EnemyBullet(bx, by, 0, 5));
                        this.shootTimer = 100 / this.speedDivisor;
                    }
                }
            }
        }
        draw() {
            ctx.save();
            ctx.fillStyle = this.color; 
            ctx.shadowColor = this.color; 
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#000'; // Ê∑±Ëâ≤ÊèèËæπ
            ctx.lineWidth = 2;

            if (this.rank === 2) { // Boss Clown
                ctx.font = '80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ü§°', this.x + this.width/2, this.y + this.height/2);
            } else if (this.rank === 1) { // Medium - ÂúÜÂΩ¢È£ûÊú∫
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
                
                // Êú∫ÁøºË£ÖÈ•∞
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + this.height/2);
                ctx.lineTo(this.x - 10, this.y + this.height);
                ctx.lineTo(this.x + 10, this.y + this.height);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(this.x + this.width, this.y + this.height/2);
                ctx.lineTo(this.x + this.width + 10, this.y + this.height);
                ctx.lineTo(this.x + this.width - 10, this.y + this.height);
                ctx.fill();

            } else { // Small - ÂúÜÂΩ¢Â∞èÈ£ûÊú∫
                ctx.beginPath();
                ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
                // Ê†∏ÂøÉÁÇπ
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 5, 0, Math.PI*2); ctx.fill();
            }
            
            // Ë°ÄÊù°
            if (this.rank === 1 && this.hp < this.maxHp) {
                ctx.fillStyle = '#2d3436'; ctx.fillRect(this.x, this.y - 10, this.width, 6);
                ctx.fillStyle = '#fdcb6e'; ctx.fillRect(this.x, this.y - 10, this.width * (this.hp/this.maxHp), 6);
            }
            ctx.restore();
        }
    }

    class EnemyBullet {
        constructor(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.remove = false; this.radius = 5; }
        update() { this.x += this.vx; this.y += this.vy; if (this.y > canvas.height || this.x < 0 || this.x > canvas.width || this.y < -50) this.remove = true; }
        draw() { ctx.save(); ctx.fillStyle = COLORS.enemyBullet; ctx.shadowColor = COLORS.enemyBullet; ctx.shadowBlur = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }

    class Particle {
        constructor(x, y, color, speed) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 8 * speed; this.vy = (Math.random() - 0.5) * 8 * speed; this.life = 1; this.color = color; this.size = Math.random() * 4 + 2; }
        update() { this.x += this.vx; this.y += this.vy; this.life -= 0.03; this.size *= 0.92; }
        draw() { ctx.save(); ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
    }

    function spawnEntities() {
        if (gameState.bossActive) return;

        if (gameState.frames % 50 === 0) {
            let mediumChance = 0.25;
            if (gameState.score > 2000) mediumChance = 0.35;
            let rank = (Math.random() < mediumChance && gameState.score > 300) ? 1 : 0;
            entities.enemies.push(new Enemy(rank));
        }
        
        if (gameState.frames % 200 === 0) {
            entities.bombs.push(new TrapBomb());
        }
        
        if (!gameState.bossActive) {
            let spawn = false;
            if (gameState.score > CONFIG.bossSpawnScore && gameState.score < CONFIG.bossSpawnScore + 200 && entities.enemies.length < 3) spawn = true;
            if (gameState.score > CONFIG.bossSpawnScore + 1000 && gameState.score % 3000 < 100) spawn = true;
            if(spawn && !entities.enemies.some(e => e.rank === 2)) spawnBoss();
        }
    }

    function spawnBoss() {
        gameState.bossActive = true;
        entities.enemies = entities.enemies.filter(e => e.rank === 1); 
        createFloatingText("WARNING: BOSS!", canvas.width/2, canvas.height/2, '#FF5252');
        setTimeout(() => { entities.enemies.push(new Enemy(2)); }, 1500);
    }

    function triggerBombExplosion(bomb) {
        bomb.remove = true;
        createExplosion(bomb.x, bomb.y, '#ff4757', 30);
        screenShake(20);
        createFloatingText("TRAP EXPLODED!", bomb.x, bomb.y, '#ff4757');
        
        entities.enemies.forEach(e => {
            let dist = Math.hypot(e.x - bomb.x, e.y - bomb.y);
            if (dist < 300) { 
                e.hp -= 200; 
                createExplosion(e.x, e.y, '#fff', 5);
                if(e.hp <= 0) {
                    e.remove = true;
                    addScore(200, e.x, e.y);
                    if (e.rank === 2) {
                        gameState.bossActive = false;
                        bossHpContainer.style.display = 'none';
                    }
                }
            }
        });
    }

    function update() {
        if (!gameState.running) return;
        updateCombo();

        if (gameState.shakeTimer > 0) {
            gameState.shakeTimer--;
            let dx = (Math.random() - 0.5) * gameState.shakeTimer;
            let dy = (Math.random() - 0.5) * gameState.shakeTimer;
            gameContainer.style.transform = `translate(${dx}px, ${dy}px)`;
        } else { gameContainer.style.transform = `none`; }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        entities.player.update();
        entities.player.draw();

        let p = entities.player;
        
        // Ê≠¶Âô®ÊßΩ‰ΩçÂèëÂ∞ÑÈÄªËæë (4ÂºπÈÅìÈôêÂà∂)
        let totalWeapons = p.activeWeapons.length;
        if(totalWeapons > 0 && gameState.frames % 10 === 0) { // Áªü‰∏ÄÂ∞ÑÈÄü
            p.activeWeapons.forEach((type, index) => {
                let cx = p.x + p.width/2;
                let offset = (index - (totalWeapons - 1) / 2) * 20; 
                
                if (type === 'laser') entities.bullets.push(new Bullet(cx + offset, p.y, 'laser'));
                else if (type === 'heavy') entities.bullets.push(new Bullet(cx + offset, p.y, 'heavy'));
                else if (type === 'homing') entities.bullets.push(new Bullet(cx + offset, p.y, 'homing'));
                else if (type === 'plasma') entities.bullets.push(new Bullet(cx + offset, p.y, 'plasma'));
                else if (type === 'rapid') entities.bullets.push(new Bullet(cx + offset, p.y, 'rapid'));
                else if (type === 'snipe') entities.bullets.push(new Bullet(cx + offset, p.y, 'snipe'));
                else if (type === 'shuriken') entities.bullets.push(new Bullet(cx + offset, p.y, 'shuriken'));
                else if (type === 'bubble') entities.bullets.push(new Bullet(cx + offset, p.y, 'bubble'));
                else if (type === 'pulse') entities.bullets.push(new Bullet(cx + offset, p.y, 'pulse'));
                else entities.bullets.push(new Bullet(cx + offset, p.y, 'normal'));
            });
        }

        if (gameState.frames % 12 === 0 && p.wingmen > 0) {
            entities.bullets.push(new Bullet(p.x - 20, p.y + 10, 'normal'));
            if(p.wingmen > 1) entities.bullets.push(new Bullet(p.x + p.width + 10, p.y + 10, 'normal'));
            if(p.wingmen > 2) entities.bullets.push(new Bullet(p.x + p.width/2 - 3, p.y + 35, 'normal', Math.PI, 6)); 
        }

        entities.bombs.forEach(bomb => {
            bomb.update(); bomb.draw();
            if (!bomb.remove && Math.hypot(bomb.x - (p.x+p.width/2), bomb.y - (p.y+p.height/2)) < (bomb.radius + p.width/3)) {
                bomb.remove = true;
                createFloatingText("TRAP!", bomb.x, bomb.y, '#ff0000');
                p.takeDamage();
            }
        });

        entities.bullets.forEach(b => {
            b.update(); b.draw();
            entities.enemies.forEach(e => {
                if (!b.remove && !e.remove && b.x < e.x + e.width && b.x + b.width > e.x && b.y < e.y + e.height && b.y + b.height > e.y) {
                    b.remove = true;
                    e.hp -= b.damage;
                    if (b.type === 'heavy') {
                        createExplosion(b.x, b.y, '#ff7675', 10);
                        entities.enemies.forEach(n => { if(Math.hypot(n.x-e.x, n.y-e.y) < 100) n.hp -= 8; });
                    } else if (b.type === 'plasma') {
                        b.remove = false; 
                    } else {
                        createExplosion(b.x, b.y, b.color, 2, 0.5);
                    }
                    if (e.hp <= 0) {
                        e.remove = true;
                        let baseScore = (e.rank === 2 ? 1000 : (e.rank === 1 ? 100 : 10));
                        addScore(baseScore, e.x, e.y);
                        createExplosion(e.x + e.width/2, e.y + e.height/2, e.color, 20);
                        let chance = CONFIG.dropChance;
                        if (e.rank === 1) chance = 0.8;
                        if (Math.random() < chance || e.rank === 2) entities.drops.push(new Drop(e.x, e.y));
                        if (e.rank === 2) {
                            gameState.bossActive = false;
                            bossHpContainer.style.display = 'none';
                            screenShake(30);
                        }
                    }
                }
            });
            entities.bombs.forEach(bomb => {
                if (!b.remove && !bomb.remove && Math.hypot(bomb.x - b.x, bomb.y - b.y) < (bomb.radius + b.width)) {
                    b.remove = true;
                    triggerBombExplosion(bomb);
                }
            });
        });

        entities.drops.forEach(d => {
            d.update(); d.draw();
            if (!d.remove && p.x < d.x + d.width && p.x + p.width > d.x && p.y < d.y + d.height && p.y + p.height > d.y) {
                d.remove = true;
                if (d.type === 'health') p.heal();
                else if (d.type === 'shield') { p.shield = true; createFloatingText("SHIELD", p.x, p.y, '#74b9ff'); }
                else if (d.type === 'wingman') { 
                    if(p.wingmen < CONFIG.maxWingmen) p.wingmen++; 
                    createFloatingText("WINGMAN", p.x, p.y, '#00cec9'); 
                }
                else {
                    // Ê≠¶Âô®
                    p.addWeapon(d.type);
                    createFloatingText(`+${d.type.toUpperCase()}`, p.x, p.y, '#ff7675');
                }
            }
        });

        entities.enemies.forEach(e => {
            e.update(); e.draw();
            if (!e.remove && p.x < e.x + e.width && p.x + p.width > e.x && p.y < e.y + e.height && p.y + p.height > e.y) {
                e.hp -= 10; if(e.hp<=0) { e.remove = true; createExplosion(e.x, e.y, e.color, 20); }
                p.takeDamage();
            }
        });

        entities.enemyBullets.forEach(eb => {
            eb.update(); eb.draw();
            if (!eb.remove && Math.hypot(eb.x - (p.x+p.width/2), eb.y - (p.y+p.height/2)) < (p.width/2 + eb.radius)) {
                eb.remove = true;
                p.takeDamage();
            }
        });

        entities.bullets = entities.bullets.filter(b => !b.remove && b.y > -50);
        entities.enemies = entities.enemies.filter(e => !e.remove);
        entities.enemyBullets = entities.enemyBullets.filter(eb => !eb.remove);
        entities.drops = entities.drops.filter(d => !d.remove);
        entities.bombs = entities.bombs.filter(b => !b.remove);
        entities.particles = entities.particles.filter(p => p.life > 0);
        entities.particles.forEach(p => { p.update(); p.draw(); });

        spawnEntities();
        gameState.frames++;
        requestAnimationFrame(update);
    }

    function startGame() {
        if (gameState.running) return;
        gameState.running = true;
        gameState.score = 0;
        gameState.frames = 0;
        gameState.combo = 0;
        scoreEl.innerText = '0';
        comboEl.classList.remove('active');
        bossHpContainer.style.display = 'none';
        damageOverlay.style.opacity = 0;
        
        entities.player = new Player();
        entities.bullets = []; entities.enemies = []; entities.enemyBullets = []; entities.drops = []; entities.particles = []; entities.bombs = [];
        
        updateHpUI();
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        input.x = canvas.width / 2; input.y = canvas.height - 100;
        update();
    }
};
</script>
</body>
</html>
